# Motion Draw

Motion Draw는 MediaPipe의 Gesture recognition을 사용하여 손동작을 인식하고 그것을 바탕으로 그림판을 구현하여 socket 통신으로 다른 사용자와 함께 그림을 그릴 수 있게 하는 프로젝트입니다.

# 목차

- [Motion Draw](#motion-draw)
- [Motivation](#motivation)
- [Challenges](#challenges)

  - [1. 어떻게 허공에서 손을 움직이는 것으로 그림을 그릴것인가?](#1-어떻게-허공에서-손을-움직이는-것으로-그림을-그릴것인가)
    - [1) 손동작 인식 Library, tenserflow vs mediapipe](#1-손동작-인식-library-tenserflow-vs-mediapipe)
    - [2) mediapipe의 출력값을 이용하여 어떻게 canvas에 표현할 것인가?](#2-mediapipe의-출력값을-이용하여-어떻게-canvas에-표현할-것인가)
    - [3) 그리기 중 색변경, 굵기변경 시 그리고 있던 선도 영향을 받는 현상 처리는 어떻게 할 것인가?](#3-그리기-중-색변경-굵기변경-시-그리고-있던-선도-영향을-받는-현상-처리는-어떻게-할-것인가)
  - [2. 어떻게 여러명이서 그림을 그릴 수 있을까?](#2-어떻게-여러명이서-그림을-그릴-수-있을까)
    - [1) 어떤 방법으로 구현할 것인가?](#1-어떤-방법으로-구현할-것인가)
    - [2) 2명이서 동시에 그릴 때 서로의 선이 이어지는 경우](#2-2명이서-동시에-그릴-때-서로의-선이-이어지는-경우)
    - [3) 그림을 그리고 있는 방에 입장시 어떻게 그리고 있던 그림을 불러올 것인가?](#3-그림을-그리고-있는-방에-입장시-어떻게-그리고-있던-그림을-불러올-것인가)

- [Schedule](#schedule)
- [Tech Stacks](#tech-stacks)
- [Repository Link](#repository-link)
- [Member](#member)

# Motivation

마우스와 타블렛PC와 같은 것이 아닌 웹캠을 이용하여 허공에 손짓으로만 그림을 그리게 된다면 얼마나 편할까? 라는 생각을 종종 하곤 했습니다. 그래서 이번 기회에 위와 같은 생각을 구현할 방법으로 딥러닝을 떠올리게 되었고 조사해보게 되었습니다.
그래서 개인 프로젝트의 목표를 특정 손동작을 웹캠에 인식시켜 허공에서 그리는 그림판을 구현하는것이 되었습니다.

# Deploy

모바일 불가합니다.

- **[MotionDraw](https://www.motiondraw.xyz/)**

# Challenges

## 1. 어떻게 허공에서 손을 움직이는 것으로 그림을 그릴것인가?

### 1) 손동작 인식 Library, tenserflow vs mediapipe

손동작을 인식하려고 구분하려고 한다면 인공지능으로 학습된 모델을 가지고 있는 Library를 찾아야 했습니다. 조사 결과 tenserflow.js에 손모양 인식 라이브러리가 있었고 그것을 사용하여 개발을 진행하려고 하였습니다. 그런데 관련 깃허브에 tenserflow.js를 사용한 예가 있었고 mediapipe를 사용한 예가 있었습니다. 둘다 같은 동작을 하지만 두가지를 비교하여 보니 mediapipe를 사용하는것이 tenserflow.js를 사용하는 것보다 제 프로젝트를 진행하는데 있어 더 빠른 성능을 보여주었기 때문에 mediapipe를 사용하게 되었습니다.

### 2) mediapipe의 출력값을 이용하여 어떻게 canvas에 표현할 것인가?

mediapipe의 gestureRecognizer는 출력값으로 gestures, handednesses, landmarks, wolrdLandmarks 총 4가지 property를 가진 객체를 반환합니다. gestures는 어떤 손모양인지 알려주는 배열이고, handednesses는 왼손인지 오른손인지 알려주는 배열, landmarks는 손을 21개의 좌표로 표현한 배열, worldLandmarks는 추후 추가 예정. 이었습니다. 위 4가지 배열 중 3가지를 배열을 이용하여 canvas에 그리는 기능과 색변경, 굵기변경 등을 구현하려고 생각했습니다. 이 부분에서 어려웠던 점이 landmarks의 배열은 x와 y좌표를 가지고 있는데 이 값은 0~1 사이의 값이었습니다. 이 값을 사용하여 어떻게 canvas에 표현할까 생각하였는데, 이 값을 canvas의 가로폭과 세로폭의 값으로 곱하고 canvas로 그려보게 되면 canvas가 webcam의 손위치와 동기화 되어 그려지게 되었습니다. 여기서 문제는 webcam과 반대방향으로 표현된 점인데 이는 canvas에 transform을 사용하여 조정하였습니다.

### 3) 그리기 중 색변경, 굵기변경 시 그리고 있던 선도 영향을 받는 현상 처리는 어떻게 할 것인가?

오른손의 그리기 모드와 왼손에서의 색변경, 굵기변경 기능을 구현 후 오른손으로 그리기 모드 중 왼손 기능을 사용하면 그리고 있던 선의 색과 굵기가 모두 바뀌는 현상이 있었습니다. 이를 해결하기 위하여 원인을 분석해 보았습니다. 기존에는 웹캠을 인식하여 일정 시간마다 lineTo 메소드를 반복하여 선을 그리는 방식이 위와 같은 결과를 나타낸다고 파악하였습니다. 기존 마우스로 그리는 그림판을 구현하는데 위와 같은 방식을 사용해도 중간에 색을바꾸거나 굵기를 바꾸는 경우가 없어서 기존의 방법이 문제가 있다는 점을 알지 못해 위와 같은 현상이 발생하였던 것이었습니다. 그래서 손동작이 일정 시간마다 인식 될 때 이전 좌표를 저장하고 이를 이용해서 이전 좌표와 현재 좌표를 잇는 방식으로 변경하여 이 문제를 해결하게 되었습니다.

## 2. 어떻게 여러명이서 그림을 그릴 수 있을까?

### 1) 어떤 방법으로 구현할 것인가?

여려명이 동시에 그림을 그리는 방법으로 `socket.io`를 사용허여 실시간으로 데이터를 주고받는 방식으로 구현하는 것을 목표로 하였습니다. 웹캠으로 손동작을 인식한 객체 데이터와 접속한 room의 제목을 `socket.io`를 이용하여 서버로 보내고 서버에서 room에 접속한 모든 사용자에게 broadcast 방식으로 객체 데이터를 보내는 방식으로 구현하였습니다. 그리고 받은 객체 데이터를 다시 각자의 사용자의 canvas에 다시 그리는 방식으로 `socket.io`를 사용한 그림판 구현을 완료하게 되었습니다.

-> 흐름도 사진 추가 예정

### 2) 2명이서 동시에 그릴 때 서로의 선이 이어지는 경우

`socket.io`로 실시간 통신을 하여 그림을 그리는것 까지는 성공하였으니 여러명의 사용자가 동시에 그림을 그리게 된다면 각 사용자의 커서가 있는 곳에 선이 서로 이어지는 현상이 있었습니다. 이도 위와 마찬가지로 `lineTo 메소드`를 반복하여 그림을 그리다보니 발생하는 문제였습니다. 그래서 이전 좌표를 기억하여 `moveTo`와 `lineTo` 메소드를 반복하여 그리는 방식으로 전환하여 해결을 하려고 했으나 이전 좌표가 공유되어 그림이 이상하게 그려지는 현상은 그대로였습니다.
그래서 저는 2가지 방법을 생각해봤습니다. 첫번째는 canvas를 사용자 늘어날때마다 추가하여 그리는 방식, 두번째는 socket id마다 이전 좌표를 기억하는 방식이었습니다. 첫번째 방법은 한 canvas에 그림을 그리지 않으면 다른 사람의 그림을 지울수 없는 문제와 두명이상이서 같은 곳을 그리게 된다면 `z-index`의 문제가 발생하여 그림을 서로 겹쳐 그릴수 없는 현상이 나타나는 문제가 있었습니다. 그래서 한 canvas에 모든 문제를 해결해야 한다고 생각하고 두번째 방법인 socket id마다 이전 좌표를 기억하는 방식으로 진행하여 이 문제를 해결하게 되었습니다.

### 3) 그림을 그리고 있는 방 입장시 어떻게 그리고 있던 그림을 불러올 것인가?

처음에는 Ready 기능을 만들어 진행중인 방에는 참가가 불가능하게 구현하였습니다. 하지만 언제든지 그림을 그리고 있는 방에 자유롭게 접속하고 나갈수 있게 구현하는 방식이 더 옳은 방향이라고 생각하였습니다. 그래서 진행중인 방에 그림을 불러오게 할 방법을 고민하게 되었습니다. 제가 생각한 방법은 redux를 사용하여 사용자가 그린 정보를 저장한 뒤 새로운 사용자가 들어오게 된다면 그 정보를 요청하고 전달받아 기존의 그림을 그려주는 방향으로 목표를 잡고 진행하였습니다. 이 부분에서 어려웠던 점은 room에 있는 누구의 정보를 가져와야 하는지 문제가 되었고, redux 설계를 어떤 방식으로 해야지 기존의 함수를 재활용 하면서 구현할수 있을까에 대한 문제가 있었습니다. 첫번쨰는 socket 통신을 하여 그림을 그릴때 모든 정보를 redux에 넣는다면 모든 사용자가 똑같은 정보를 가지고 있기 때문에 누구에게나 정보를 받아도 상관이 없을것이라고 생각하고 가장 오래있었던 사용자의 정보를 가져오는 방향으로 구현하였습니다. 두번째는 redux의 구조를 socket id마다 정보를 가지고 있는 식으로 구현하려고 했지만 이 방식을 사용하면 그려진 시간이 섞여서 원래의 정보와 다르게 표시될 가능성이 있었습니다. 이를 방지하기 위하여 하나의 배열에 시간순으로 정보를 넣고 그 정보를 다시 함수를 재활용하여 그리는 방식으로 구현하였습니다.

## 3. UX 개선

### 1) 일정 시간 후 커서 사라지게 만들기
여러명의 사용자가 방에 들어와서 그림을 그리게 되고 사용자가 많아지면 여러개의 커서가 생기게 됩니다. 그렇게 되면 사용자가 잠시 그림을 그리는 것을 쉬게 되더라도 커서는 화면 위에 표시되게 됩니다. 그 부분이 사용자 입장에서 거슬릴 수 있는 부분이라 생각했기 때문에 움직임이 없는 상태로 5초가 지나게 되면 커서를 보이지 않게 만드는 기능을 구현하게 하였습니다.

<img src="https://github.com/MotionDraw/MotionDraw-Client/assets/107802867/324f5343-58a8-4b4a-ac3a-47e9a9cba45c"  width="400" height="300"/>

### 2) 마우스로 선굵기 조절 및 색 선택 기능
그림을 그리다가 손동작으로 선굵기를 조절하거나 색을 선택 하는것에 답답함을 느낄 사용자도 있을것이라 생각했습니다. 그래서 드래그로 선굵기를 조절하고 마우스 클릭으로 색선택을 할 수 있게 만들어 빠른 변환이 가능한 기능을 구현하게 되었습니다.

<img src="https://github.com/MotionDraw/MotionDraw-Client/assets/107802867/1ce86ca8-3b03-44f3-860b-3c231b418403"  width="400" height="300"/>

### 3) 모드 변경 및 색 변경시 커서에 progress bar 구현
굵기를 조절하기 다음 색으로 넘어가기 기능 등 다른 모드로 변경되는데 시간이 걸리는 기능들이 있었습니다. 하지만 사용자가 모드가 변경되는데 시간이 얼마나 소요되는지 모른다면 불편할것이라 생각했습니다. 그래서 시간관리를 redux를 사용하여 관리해서 커서에 progress bar 기능을 추가하여 구현하였습니다.

<img src="https://github.com/MotionDraw/MotionDraw-Client/assets/107802867/cdf3d4b2-0dfc-44e1-a74e-1483288f7fc9"  width="400" height="300"/>

### 4) 색상 호버링시 색 변경 기능
사용자가 마우스로 색변경이나 색변경 모드로 색깔을 바꾸는 방식이 아닌 팔레트에 붓을 찍어서 그림을 구현하는 방식처럼 마우스를 색에 호버링하면 그 색을 사용하도록 한다면 사용하기 편할 것이라고 생각하였습니다. 그래서 마우스를 색에 호버링 시 색이 변경하는 기능을 구현하였습니다.

<img src="https://github.com/MotionDraw/MotionDraw-Client/assets/107802867/949fd312-7fc9-4470-ac5f-c425c515e397"  width="400" height="300"/>

## 4. 성능 개선 방향

### 어떻게 해야 그림을 더 부드럽게 그릴 수 있을까?

그림 그릴 때 가끔 화면이 버벅이는것처럼 느껴지는 이유를 조사해봤습니다. 브라우저는 한 프레임당 16.67ms 1초에 60번의 프레임을 보여주는식으로 동작합니다. 하지만 손동작을 인식하고 그림을 그리는 함수의 실행시간이 49ms에서 120ms사이로 동작하는 것을 개발자 도구의 Performance 측정으로 알아냈습니다. 함수에서 대부분의 시간은 MideaPipe에서 손동작을 인식하는 함수에서 소요되는 것으로 파악됐습니다.

그래서 성능을 개선할 수 있는 가능성 중 하나는 MideaPipe의 함수 실행시간을 단축하는 방법과 함수 실행시간을 단축하지 못하더라도 똑같은 함수가 두번 호출되는 현상을 파악하여 막을 수 있는 방식을 알아낸다면 성능을 개선시킬 수 있을것아리 생각합니다.

다른 방법으로는 성능을 개선시키기 위하여 setTimeout 동작방식과 rAF(requestAnimationFrame)의 동작 방식을 비교했을 때 rAF로 동작하는 방식이 브라우저의 최적화되어 효율적인 애니메이션을 구현할 것이라 예상하였습니다. 하지만 실제로 두가지 방법을 모두 사용해 보았을때 rAF는 그림이 끊기면서 그려지고 setTimeout 방식이 더 부드럽고 끊기지 않게 그려지는 상황이 일어났습니다.


<img src="https://github.com/MotionDraw/MotionDraw-Client/assets/107802867/b27e576c-94f9-4eeb-842b-d4ebbcc4ced4"  width="400" height="300"/>
<img src="https://github.com/MotionDraw/MotionDraw-Client/assets/107802867/00b63048-9275-4941-8bb3-f2a8b1e3cb96"  width="400" height="300"/>

# Schedule

### 프로젝트 기간 : 2023.04.03(월) ~ 2023.04.24(금) / 3주

1주차 : 기획 및 설계

- 아이디어 수집
- 기술 스택 선정
- Figma를 사용한 Mockup 제작
- Notion에 Kanban 작성

2~3주차 : 기능 개발

- 프론트 엔드 구현
- 백엔드 서버 구현

# Tech Stacks

### Frontend

- React
- React-Router
- Redux-Toolkit
- styled-component
- socket.io-client
- ESLint

### Backend

- Node.js
- Express
- socket.io
- ESLint

# Repository Link

- [Frontend](https://github.com/MotionDraw/MotionDraw-Client)
- [Backend](https://github.com/MotionDraw/MotionDraw-Server)

# Member

- 강현준 : steady.kang27@gmail.com
